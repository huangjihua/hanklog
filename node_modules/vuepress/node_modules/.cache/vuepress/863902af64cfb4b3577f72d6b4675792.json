{"remainingRequest":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/index.js??ref--1-1!/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Volumes/PersonHD/Company Project/github/hankLog/docs/basics/EventLoop.md?vue&type=template&id=08164533&","dependencies":[{"path":"/Volumes/PersonHD/Company Project/github/hankLog/docs/basics/EventLoop.md","mtime":1536111099000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Volumes/PersonHD/Company Project/github/hankLog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"eventloop\"><a class=\"header-anchor\" href=\"#eventloop\" aria-hidden=\"true\">#</a> EventLoop</h1>\n<h2 id=\"event-loop如何理解\"><a class=\"header-anchor\" href=\"#event-loop如何理解\" aria-hidden=\"true\">#</a> Event loop如何理解</h2>\n<p>面试的经常会被问到，什么事Event loop，面试官想知道什么呢，我们又该如何回答呢？</p>\n<p>Event Loop顾名思义就是事件循环，为什么要用事件循环？因为V8是<code>单线程</code>的，即同一时间只能干一件事情，但是文件的读取和网络IO处理会很慢，并且时间不确定的，如果同步等待它们的响应，估计用户早飞了，于是我们就把这个事件加入到一个<code>事件队里（task）</code>,等到事件完成时，event loop再执行一个事件队列。</p>\n<h2 id=\"event-loop执行顺序\"><a class=\"header-anchor\" href=\"#event-loop执行顺序\" aria-hidden=\"true\">#</a> Event loop执行顺序</h2>\n<p>注意：每种异步事件加入的事件队列是不一样的，唯一的2个限制是同一个任务源中的事件必须属于同一个队列，并且必须在每个队列中按照插入顺序处理任务。也就是说由系统提供的执行task的方法，如 setTimeout/setInterval/setImmediate 会在一个task，网络IO会在一个task,用户事件会在一个task,event loop将会按照以下顺序执行：</p>\n<ul>\n<li>1.update_time<br>\n在事件循环的开头，这一步的作用实际上是为了获取以下系统时间，以保证之后的timer触发的准确性。（好像也不太准确...）</li>\n<li>2.timer<br>\n事循环跑到这个阶段的时候，要检查是否有到期的timer,其实也就是setTimeout和setInterval这种类型的timer,到期了，就会执行他们的回调。</li>\n<li>3.I/O callbacks<br>\n处理异步事件的回调，比如网络I/O,比如文件读取I/O。当这些I/O动作都结束的时候，这个阶段会触发他们的回调。</li>\n<li>4.idle,prepare<br>\n这个阶段内部做一些动作，与理解事件循环没啥关系</li>\n<li>5.I/O poll阶段<br>\n这个阶段相当有意思，也是事件循环设计的一个有趣的点，这个阶段是<code>选择运行</code>（不一定会运行，后续详解）的。</li>\n<li>6.check<br>\n执行setImmediate操作</li>\n<li>\n<ol start=\"7\">\n<li>Close callbacks<br>\n关闭I/O 的动作，比如文件描述符的关闭，链接断开，等等<br>\n<img src=\"/images/eventloop-1.jpg\" alt=\"Event loop执行顺序\"></li>\n</ol>\n</li>\n</ul>\n<p>除了task还有一个<code>microtask</code>（微任务），这一个概念是ES6提出<code>Promise</code>以后出现的。这个<code>microtask queue</code>只有一个。并且会在且一定会在每一个task后执行，且执行是按顺序的。加入到<code>microtask</code>的事件类型有<code>Promise.resolve().then()</code>, <code>process.nextTick()</code> 值得注意的是，event loop一定会在执行完<code>microtask</code>以后才会寻找新的可执行的task队列。而<code>microtask</code>事件内部又可以产生新的<code>microtask</code>事件比如</p>\n<!--beforebegin--><div class=\"language-javascript line-numbers-mode\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token function\">microtask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    process<span class=\"token punctuation\">.</span><span class=\"token function\">nextTick</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">microtask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<div class=\"line-numbers-wrapper\"><span class=\"line-number\">1</span><br><span class=\"line-number\">2</span><br><span class=\"line-number\">3</span><br></div><!--beforeend--></div><!--afterend--><p>这样就会不断的在<code>microtask queue</code>添加事件，导致整个eventloop堵塞</p>\n<p>最后就是一个渲染的事件队列，这个队列只出现在浏览器上，并且执行环境会根据情况决定执行与否(可能执行很多task queue也不执行渲染队列)。它如果执行则一定会在microtask后执行，通过<code>requestAnimationFrame(handle)</code> 方法,能够保证中间的代码一定能在下一次执行渲染函数前执行</p>\n<p>补充常见的产生<code>microtask</code>和<code>task</code>事件的方法<br>\n<strong>microtasks:</strong></p>\n<ul>\n<li>process.nextTick</li>\n<li>promise</li>\n<li>Object.observe</li>\n<li>MutationObserver<br>\n<strong>tasks:</strong></li>\n<li>setTimeout</li>\n<li>setInterval</li>\n<li>setImmediate</li>\n<li>I/O</li>\n<li>UI渲染</li>\n<li>Tips</li>\n</ul>\n<p>我们通过node运行一个js文件，如果没有可执行事件的事件队列，进程就会退出，那么怎么不让它退出呢？<br>\nsetInterval方法，这货会一直循环建立新的事件，这样能够保证node进程不退出</p>\n<p>监听 beforeExit 事件，通过process.on('beforeExit', handle) 这个事件在node进程退出前会触发，但是如果这里面的handle包含了一个可以生成异步事件的操作，则node进程也不会退出。手动触发process.exit(EXIT_CODE)不会触发该事件</p>\n<p>setInterval会导致node进程不能正常退出，但是如果希望即使有setInterval也能正常退出怎么办(有一些循环并不希望挂起node进程)？<br>\nconst timer = process.setInterval(handle, deley) 调用setInterval方法会返回一个timer，调用 timer.unref() 则event-loop判断除它以外，没有可进行的事件队列后也会推出</p>\n<p>process.on('exit', handle)中，handle里的异步事件不能执行<br>\nexit事件在手动执行process.exit(EXIT_CODE)后，或者event loop中没有可执行的事件队列 时触发。触发 exit 事件后，执行环境就不会再生成新的 事件队列了，因此这里面的异步事件都会被强制队列</p>\n</div>\n",null]}